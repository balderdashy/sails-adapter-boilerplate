// Generated by CoffeeScript 1.4.0
(function() {
  var MAX_INTEGER, RiakDB, TRANSACTION_WARNING_TIMEOUT, async, asyncSeriesPromise, deferred, promisify, uuid, _,
    __hasProp = {}.hasOwnProperty;

  MAX_INTEGER = 4294967295;

  TRANSACTION_WARNING_TIMEOUT = 2000;

  deferred = require('deferred');

  promisify = deferred.promisify;

  _ = require('underscore');

  _.str = require('underscore.string');

  _.mixin(_.str.exports());

  uuid = require('node-uuid');

  async = require('async');

  asyncSeriesPromise = promisify(async.series);

  RiakDB = require('./riak-db');

  module.exports = (function() {
    var adapter, connect, connections, getMatchIndices;
    getMatchIndices = require('./criteria');
    connections = {};
    adapter = {
      syncable: true,
      commitLog: {
        identity: 'commit_log',
        adapter: 'sails-riak',
        dbTag: 'transactions',
        port: 8098,
        host: 'localhost',
        migrate: 'drop',
        funcTable: {}
      },
      defaults: {
        port: 8098,
        host: 'localhost',
        migrate: 'drop',
        dbTag: 'test'
      },
      registerCollection: function(collection, cb) {
        var afterwards, collectionName, foundConnection,
          _this = this;
        collectionName = collection.identity;
        afterwards = function() {
          var db, _schema;
          db = connections[collectionName].db;
          _schema = {};
          return db.describeSchema(collectionName).then(function(schema) {
            if (schema != null) {
              return deferred(schema);
            } else {
              return deferred({
                autoIncrement: 1
              });
            }
          }).then(function(schema) {
            _schema = schema;
            return db.get(collectionName, schema.autoIncrement).then(function(model) {
              if (model != null) {
                return db.getMaxIndex(collectionName);
              } else {
                return deferred(-1);
              }
            });
          }).then(function(maxIndex) {
            if (maxIndex !== -1) {
              _schema.autoIncrement = maxIndex + 1;
              return promisify(_this.define)(collectionName, _schema);
            } else {
              return deferred(null);
            }
          }).end(function() {
            return cb();
          }, function(err) {
            return cb(err);
          });
        };
        collectionName = collection.identity;
        foundConnection = _.find(connections, function(connection) {
          return connection && (connection.db.tag === collection.dbTag);
        });
        if (foundConnection != null) {
          connections[collection.identity] = foundConnection;
          return afterwards();
        } else {
          connect(collection, function(err, connection) {
            return connections[collection.identity] = connection;
          });
          return afterwards();
        }
      },
      teardown: function(cb) {
        return cb();
      },
      define: function(collectionName, definition, cb) {
        var db, options;
        db = connections[collectionName].db;
        definition = _.extend({
          autoIncrement: 1
        }, definition);
        options = {};
        options.search = collectionName === this.commitLog.identity;
        return db.defineSchema(collectionName, definition, options).end(function() {
          return cb();
        }, function(err) {
          return cb(err);
        });
      },
      describe: function(collectionName, cb) {
        var db;
        db = connections[collectionName].db;
        return db.describeSchema(collectionName).end(function(schema) {
          return cb(null, schema != null ? schema.attributes : void 0);
        }, function(err) {
          if (err.statusCode === 404) {
            return cb();
          } else {
            return cb(null, err);
          }
        });
      },
      drop: function(collectionName, cb) {
        var db;
        db = connections[collectionName].db;
        return db.deleteAll(collectionName).then(function() {
          return db.deleteSchema(collectionName);
        }).end(function() {
          return cb();
        }, function(err) {
          return cb(err);
        });
      },
      create: function(collectionName, values, cb) {
        var db,
          _this = this;
        db = connections[collectionName].db;
        values = _.clone(values) || {};
        return promisify(function(cb) {
          if (collectionName === _this.commitLog.identity) {
            return _this.saveLockMethods(values).end(function(values) {
              return cb(null, values);
            }, function(err) {
              return cb(err);
            });
          } else {
            return cb(null, values);
          }
        })().then(function(values) {
          return db.create(collectionName, values).then(function(model) {
            if (collectionName === _this.commitLog.identity) {
              return _this.restoreLockMethods(model);
            } else {
              return deferred(model);
            }
          });
        }).end(function(model) {
          return cb(null, model);
        }, function(err) {
          return cb(err);
        });
      },
      find: function(collectionName, options, cb) {
        var db,
          _this = this;
        db = connections[collectionName].db;
        return db.getAllModels(collectionName).then(function(models) {
          var matchIndex, matchIndices, resultSet, _i, _len;
          matchIndices = getMatchIndices(models, options);
          resultSet = [];
          for (_i = 0, _len = matchIndices.length; _i < _len; _i++) {
            matchIndex = matchIndices[_i];
            resultSet.push(_.clone(models[matchIndex]));
          }
          if (collectionName === _this.commitLog.identity) {
            return deferred.map(resultSet, function(model) {
              return _this.restoreLockMethods(model);
            });
          } else {
            return deferred(resultSet);
          }
        }).end(function(models) {
          return cb(null, models);
        }, function(err) {
          return cb(err);
        });
      },
      update: function(collectionName, options, values, cb) {
        var db;
        db = connections[collectionName].db;
        return this.getAutoIncrementAttribute(collectionName, function(err, aiAttr) {
          if (err != null) {
            return cb(err);
          } else {
            return db.getAllModels(collectionName).then(function(models) {
              var matchIndex, matchIndices, _i, _len;
              matchIndices = getMatchIndices(models, options);
              for (_i = 0, _len = matchIndices.length; _i < _len; _i++) {
                matchIndex = matchIndices[_i];
                models[matchIndex] = _.extend(models[matchIndex], values);
              }
              return deferred.map(matchIndices, function(matchIndex) {
                return db.save(collectionName, models[matchIndex][aiAttr], models[matchIndex]);
              });
            }).end(function(savedModels) {
              return cb(null, savedModels);
            }, function(err) {
              return cb(err);
            });
          }
        });
      },
      destroy: function(collectionName, options, cb) {
        var db;
        db = connections[collectionName].db;
        return this.getAutoIncrementAttribute(collectionName, function(err, aiAttr) {
          if (err != null) {
            return cb(err);
          } else {
            return db.getAllModels(collectionName).then(function(models) {
              var matchIndices;
              matchIndices = getMatchIndices(models, options);
              return deferred.map(matchIndices, function(matchIndex) {
                return db.remove(collectionName, models[matchIndex][aiAttr]);
              });
            }).end(function() {
              return cb(null);
            }, function(err) {
              return cb(err);
            });
          }
        });
      },
      stream: function(collectionName, options, stream) {
        var db;
        db = connections[collectionName].db;
        return db.getAllModels(collectionName).end(function(models) {
          var matchIndex, matchIndices, _i, _len;
          matchIndices = getMatchIndices(models, options);
          for (_i = 0, _len = matchIndices.length; _i < _len; _i++) {
            matchIndex = matchIndices[_i];
            stream.write(_.clone(models[matchIndex]));
          }
          return stream.end();
        }, function() {
          return stream.end();
        });
      },
      transaction: function(transactionName, atomicLogic, afterUnlock) {
        var acquireLock, collectionName, db, getNextLock, newLock, releaseLock,
          _this = this;
        getNextLock = function(locks, currentLock) {
          var lock, minId, nextLock, _i, _len;
          nextLock = null;
          minId = MAX_INTEGER;
          for (_i = 0, _len = locks.length; _i < _len; _i++) {
            lock = locks[_i];
            if (lock.name !== currentLock.name) {
              continue;
            }
            if (lock.uuid === currentLock.uuid) {
              continue;
            }
            if (nextLock != null) {
              minId = nextLock.id;
            }
            if (lock.id < minId) {
              nextLock = lock;
            }
          }
          return nextLock;
        };
        acquireLock = function(newLock) {
          var warningTimer;
          warningTimer = setTimeout(function() {
            return console.error("Transaction :: " + newLock.name + " is taking an abnormally long time (> " + TRANSACTION_WARNING_TIMEOUT + " ms)");
          }, TRANSACTION_WARNING_TIMEOUT);
          return newLock.atomicLogic(null, function() {
            clearTimeout(warningTimer);
            return releaseLock(newLock, arguments);
          });
        };
        releaseLock = function(currentLock, afterUnlockArgs) {
          var cb, nextInLine;
          cb = currentLock.afterUnlock;
          nextInLine = null;
          return db.search(collectionName, "name:" + transactionName).then(function(searchResults) {
            nextInLine = getNextLock(_.map(searchResults, function(searchResult) {
              return searchResult.fields;
            }), currentLock);
            if (nextInLine != null) {
              return _this.restoreLockMethods(nextInLine);
            } else {
              return deferred(null);
            }
          }).then(function(restoredLockObject) {
            nextInLine = restoredLockObject;
            return db.remove(collectionName, currentLock.id);
          }).end(function() {
            if (cb != null) {
              cb.apply(null, afterUnlockArgs);
            }
            if (nextInLine != null) {
              return acquireLock(nextInLine);
            }
          }, function(err) {
            return typeof cb === "function" ? cb(err) : void 0;
          });
        };
        collectionName = this.commitLog.identity;
        db = connections[collectionName].db;
        newLock = {
          uuid: uuid.v4(),
          name: transactionName,
          atomicLogic: atomicLogic,
          afterUnlock: afterUnlock
        };
        return (promisify(this.create)(collectionName, newLock)).then(function(createdLock) {
          newLock = createdLock;
          return db.search(collectionName, "name:" + transactionName);
        }).end(function(searchResults) {
          var conflict, searchResult, _i, _len;
          conflict = null;
          for (_i = 0, _len = searchResults.length; _i < _len; _i++) {
            searchResult = searchResults[_i];
            if (searchResult.fields.uuid !== newLock.uuid && searchResult.id < newLock.id) {
              conflict = _.extend({
                id: searchResult.id
              }, searchResult.fields);
              break;
            }
          }
          if (conflict == null) {
            return acquireLock(newLock);
          }
        }, function(err) {
          return atomicLogic(err, function() {
            throw err;
          });
        });
      },
      saveLockMethods: promisify(function(model, cb) {
        var attrName;
        if (model.uuid != null) {
          this.commitLog.funcTable[model.uuid] = {};
          for (attrName in model) {
            if (!__hasProp.call(model, attrName)) continue;
            if (_.isFunction(model[attrName])) {
              this.commitLog.funcTable[model.uuid][attrName] = model[attrName];
            }
          }
          return cb(null, model);
        } else {
          return cb(new Error("Commit-log model must have the UUID property defined."));
        }
      }),
      restoreLockMethods: promisify(function(model, cb) {
        var funcName, _ref;
        if (!(model.uuid != null)) {
          return cb(new Error("Commit-log model must have the UUID property defined."));
        }
        if (!(this.commitLog.funcTable[model.uuid] != null)) {
          return cb(new Error("Cannot find callbacks for commit-log entry with UUID: " + model.uuid));
        }
        _ref = this.commitLog.funcTable[model.uuid];
        for (funcName in _ref) {
          if (!__hasProp.call(_ref, funcName)) continue;
          model[funcName] = this.commitLog.funcTable[model.uuid][funcName];
        }
        return cb(null, model);
      })
    };
    connect = function(collection, cb) {
      return cb(null, {
        db: new RiakDB(collection)
      });
    };
    return adapter;
  })();

}).call(this);
